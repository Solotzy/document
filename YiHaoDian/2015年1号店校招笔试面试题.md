# 数据结构和算法题目
##### 作者：欧阳业伟
##### 编写日期：2015年9月17日

------------
### **选择题**

1号店的***每一件产品往往都会有多个商家***在销售，```产品表（product表）```和```产品-商家表（pm_info表）```如下：

product表结构如下：

| 字段 | 注释  |
|:-----| :-----|
| id   | 产品id |
| product_cname | 产品名称 |
| is_delete | 标记记录是否有效, 0表示失效, 1表示有效 |

pm_info表结构如下：

| 字段 | 注释  |
|:-----| :-----|
| product_id | 产品id |
| merchant_id | 商家id |

现在实习生Tom同学想知道1号店的每一件产品对应哪些商家，聪明的你，告诉Tom答案吧：

A. 
```sql
select 
    a.id,
    a.product_cname,
    b.merchant_id
from product a 
inner join pm_info b on (a.product_id = b.product_id)
where a.is_delete = 1;
```
B.
```sql
select 
    a.id,
    a.product_cname,
    b.merchant_id
from product a 
right outer join pm_info b on (a.product_id = b.product_id)
where a.is_delete = 0;
```
C.
```sql
select 
    a.id,
    a.product_cname,
    b.merchant_id
from product a 
left outer join pm_info b on (a.product_id = b.product_id)
where a.is_delete = 0;
```
D.
```sql
select 
    a.id,
    a.product_cname,
    b.merchant_id
from product a 
join pm_info b on (a.product_id = b.product_id)
where a.is_delete = 0;
```

**本题选C**


### **编程题**
```
题目：
从一个无序整数序列N（N长度不超过10000）中取出最长连续递增子数列。

样例输入：
-1 0 9 8 5 1 3 2 4 5 6 8 1

样例输出：
2 4 5 6 8
```

本题，我的解法是深度优先搜索（DFS）

**约定**：
+ max_length：记录最长连续递增子序列的长度
+ record：记录最长连续递增子序列

**伪代码如下：**
```
for i+1 on 无序整数数组A
do
    longestList[0] = A[i-1]
    dfs（A，i，length=1，record）
done

dfs逻辑如下：
递归出口：索引越界
递归终点：当前序列长度 > max_length
递归逻辑：
if A[当前索引] >= A[当前索引-1]
then
    record[length++] = A[i]
    dfs(A, i+1, length, record)
```
Java实现如下：
```java

/**
 * 
 * @author ouyangyewei
 *
 */
public class LongestIncreasingSubsequences {

    /** 序列最长长度 */
    public static final int MAX_SIZE    = 10010;

    /** 记录最长递增子序列的最长长度 */
    public static int       max_length  = 0;
    
    /** 记录最长递增子序列的序列串 */
    public static int[]     longestList = new int[MAX_SIZE];
    
    /**
     * 
     * @param array
     * @param lastIndex
     * @param length
     * @param record
     */
    public static void dfs(int[] array, 
            int index, 
            int length,
            int[] record) {
        if (index >= array.length) {
            return ;
        }
        if (length > max_length) {
            max_length = length;
            for (int i=0; i<max_length; ++i) {
                longestList[i] = record[i];
            }
        }
        if (array[index] >= array[index-1]) {
            record[length++] = array[index];
            dfs(array, index + 1, length, record);
        }
        
        return ;
    }

    /**
     * 
     * @param args
     */
    public static void main(String[] args) {
        // sample input
        int[] array = {-1,0,9,8,5,1,3,2,4,5,6,8,1};
        
        int[] record = new int[MAX_SIZE];
        for (int i=1; i<array.length; ++i) {
            record[0] = array[i-1];
            dfs(array, i, 1, record);
        }
        
        // sample output
        for (int i=0; i<max_length; ++i) {
            System.out.print(longestList[i] + " ");
        }
    }
}
```